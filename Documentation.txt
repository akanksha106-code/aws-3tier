
# AWS 3-Tier Web Architecture

## Project Executive Summary

**Problem:**
Traditional monolithic architectures often host the database, application server, and web server on a single instance. This creates a Single Point of Failure (SPoF), scales inefficiently, and poses significant security risks by exposing the database layer to the public internet.

**Action:**
I designed and implemented a decoupled 3-tier architecture on AWS. This involved segregating the environment into three distinct layers:

1.  **Presentation Layer (Web Tier):** Handles HTTP requests and serves static content.
2.  **Logic Layer (App Tier):** Processes API requests and business logic.
3.  **Data Layer (Database Tier):** Stores and retrieves application data.

I utilized VPCs with public and private subnets, Application Load Balancers (ALB) for traffic distribution, and Auto Scaling Groups for high availability.

**Outcome:**
The result is a highly available, fault-tolerant system. The database is strictly isolated in a private subnet, accessible only by the application server, significantly reducing the attack surface. The architecture allows each tier to scale independently based on traffic demand.

-----


### Infrastructure Components

  * **VPC:** Custom Virtual Private Cloud for network isolation.
  * **Web Tier:** Nginx web servers in public subnets, fronted by an internet-facing ALB.
  * **App Tier:** Node.js application servers in private subnets, fronted by an internal ALB.
  * **Database Tier:** Amazon RDS (MySQL) in private subnets with Multi-AZ redundancy.
  * **Security:** Tight Security Group rules ensuring traffic flows only from Web → App → DB.

-----

## Technical Implementation Guide

### Phase 1: Network Foundation (VPC & IAM)

I established the network topology to support secure communication between tiers.

  * **VPC Design:** Created a VPC with Public Subnets (for NAT Gateway and Web Tier) and Private Subnets (for App Tier and RDS).
  * **IAM Configuration:** Created an IAM role with `AmazonS3ReadOnlyAccess`. This was attached to EC2 instances to allow secure retrieval of code artifacts without hardcoding AWS credentials.

### Phase 2: Database Layer Configuration

**Action:** deployed an Amazon RDS MySQL instance in the private subnet.
**Security:** Configured Security Groups to reject all traffic except connections on port 3306 originating specifically from the App Tier Security Group.

**Schema Initialization:**
I connected to the RDS instance via a bastion host to set up the initial schema:

```sql
-- Create Database
CREATE DATABASE webappdb;
USE webappdb;

-- Create Transaction Table
CREATE TABLE IF NOT EXISTS transactions(
  id INT NOT NULL AUTO_INCREMENT,
  amount DECIMAL(10,2),
  description VARCHAR(100),
  PRIMARY KEY(id)
);

-- Seed Data for Connectivity Test
INSERT INTO transactions (amount, description) VALUES ('400', 'groceries');
```

### Phase 3: Application Tier (Backend Logic)

**Action:** Configured the application logic layer using Node.js.

**1. Configuration Management:**
Updated the `application-code/app-tier/DbConfig.js` to point to the RDS endpoint:

```javascript
module.exports = Object.freeze({
    DB_HOST: 'YOUR_RDS_ENDPOINT',
    DB_USER: 'admin',
    DB_PWD: 'YOUR_DB_PASSWORD',
    DB_DATABASE: 'webappdb'
});
```

**2. Instance Provisioning:**
Executed the following script on the App Tier instances to install dependencies, download source code from S3, and start the service using PM2.

```bash
# Install MySQL Client and Node.js
sudo yum install mysql -y
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash
source ~/.bashrc
nvm install 16 && nvm use 16

# Install PM2 Process Manager
npm install -g pm2

# Retrieve Code Artifacts
sudo aws s3 cp s3://YOUR_BUCKET_NAME/application-code/app-tier/ app-tier --recursive

# Launch Application
cd app-tier/
npm install
pm2 start index.js
pm2 startup
pm2 save
```

**3. Internal Traffic Routing:**
Configured an **Internal Application Load Balancer** to distribute traffic across the App Tier instances.

### Phase 4: Web Tier (Presentation Layer)

**Action:** Deployed Nginx as a reverse proxy to forward API requests to the internal application layer.

**1. Nginx Reverse Proxy Configuration:**
Modified `nginx.conf` to proxy API traffic to the Internal ALB DNS, keeping the backend hidden from the public internet.

```nginx
location /api/ {
    proxy_pass http://INTERNAL_ALB_DNS:80/;
}
```

**2. Web Server Provisioning:**
Configured the web instances to serve the React frontend and route API calls.

```bash
# Install Nginx and Node.js
sudo amazon-linux-extras install nginx1 -y
nvm install 16 && nvm use 16

# Retrieve Frontend Artifacts
aws s3 cp s3://YOUR_BUCKET_NAME/application-code/web-tier/ web-tier --recursive

# Build and Deploy
cd web-tier
npm install && npm run build

# Apply Nginx Config
sudo rm /etc/nginx/nginx.conf
sudo aws s3 cp s3://YOUR_BUCKET_NAME/nginx.conf /etc/nginx/nginx.conf
sudo service nginx restart
```

### Phase 5: Production Readiness (DNS & SSL)

To ensure the application was production-ready and secure:

1.  **Load Balancing:** Deployed an Internet-facing ALB to route external traffic to the Web Tier.
2.  **Encryption:** Generated an SSL certificate via AWS Certificate Manager (ACM) and attached it to the ALB HTTPS listener.
3.  **DNS Mapping:** Created a Route 53 A-Record (Alias) to map the custom domain to the External ALB.

-----

## Validation & Testing

To verify the integrity of the architecture, I performed the following checks:

1.  **End-to-End Test:** Accessed the web application via the public domain.
2.  **Database Persistence:** Created a transaction in the UI and verified the record existed in the RDS MySQL table via the command line.
3.  **Health Checks:** Verified `pm2 status` on the App Tier and Target Group health checks in the AWS Console.

-----

## Resource Teardown

To maintain cost efficiency, the following resource termination order is observed:

1.  Auto Scaling Groups.
2.  Load Balancers (External & Internal) and Target Groups.
3.  EC2 AMIs and Snapshots.
4.  RDS Instance and DB Subnet Groups.
5.  S3 Bucket (Emptied and Deleted).
6.  Route 53 Records and ACM Certificates.
7.  NAT Gateways and Elastic IPs.
8.  Virtual Private Cloud (VPC).

